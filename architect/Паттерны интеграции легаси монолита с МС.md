Интеграция legacy-монолита (особенно ядра банковской системы) с микросервисами — это не просто технология, это **стратегия минимизации рисков**. Вот ключевые паттерны и их компромиссы с точки зрения надежности, которая в банковском контексте равна доступности и консистентности данных.

### Ключевые паттерны интеграции

| Паттерн | Суть | Пример в банке |
| :--- | :--- | :--- |
| **Strangler Fig (Рис-душитель)** | Постепенное «вытеснение» функций из монолита новыми сервисами через прокси-маршрутизатор. | Создание отдельного **Сервиса платежей**, который берет на себя одну операцию из монолита. Весь трафик на `/api/payments` идет через роутер: сначала в новый сервис, а если операция старая — в монолит. |
| **Anti-Corruption Layer (ACL)** | Прослойка, которая изолирует новую систему от устаревшей, переводя между разными моделями данных и протоколами. | Новый **Мобильный банк** работает только с ACL. ACL преобразует его современные REST-запросы в устаревший SOAP/XML формат ядра и обратно, защищая новый код от «мусора» легаси. |
| **Backends for Frontends (BFF)** | Отдельный шлюз-адаптер **для каждого клиентского типа**, агрегирующий данные из монолита и сервисов. | **BFF для мобильного приложения** делает один запрос, чтобы получить: баланс (из монолита), акции (из сервиса маркетинга) и историю (из сервиса транзакций). |
| **CQRS (Command Query Responsibility Segregation)** | Разделение модели на **команды** (запись, идущая часто в монолит) и **запросы** (чтение, идущее в оптимизированную БД или кэш). | **Команда «Списать деньги»** идет в монолит. **Запрос «Показать выписку»** идет в отдельную читальную БД, куда данные реплицируются из монолита. |
| **Saga (с асинхронной коммуникацией)** | Оркестрация распределенной транзакции между сервисами и монолитом через последовательность **компенсирующих событий**. | Процесс **«Оформление кредита»** включает: 1) проверку клиента (в сервисе KYC), 2) расчет (в сервисе скоринга), 3) создание счета (в монолите). Если скоринг провален, запускается компенсация — отмена созданных записей. |

### Trade-offs в контексте надежности (Availability & Consistency)

Здесь ключевой выбор — между **мгновенной консистентностью** и **высокой доступностью**, который описывается теоремой CAP.

| Паттерн | Надежность: Плюсы (Availability +) | Надежность: Риски и Компромиссы (Consistency / Complexity -) | **Когда выбирать** |
| :--- | :--- | :--- | :--- |
| **Strangler Fig** | **Постепенность**: Нет «Big Bang». Высокая доступность основной системы сохраняется. | **Сложность маршрутизации**: Роутер становится критической точкой (SPOF). Требует тщательного тестирования. | Для **поэтапной трансформации** без остановки бизнеса. |
| **Anti-Corruption Layer** | **Изоляция от сбоев**: Сбои в монолите можно обработать в ACL (например, вернуть заглушку). Защита от изменений в монолите. | **Задержка (latency)**: Добавлен еще один сетевой прыжок и преобразование данных. **Двойная модель данных** — сложность поддержки. | Когда **модель монолита устарела или токсична**, а протоколы несовместимы. |
| **BFF** | **Оптимизация для клиента**: Улучшает доступность и отзывчивость интерфейсов. Позволяет **деградировать функционал** (например, не показывать акции, если их сервис лежит). | **Дублирование логики**: Похожая логика может появиться в BFF для веба и мобилы. **Еще одна точка отказа**. | Когда у вас **кардинально разные клиенты** (мобилка, веб, партнерский API) с разными потребностями в данных. |
| **CQRS** | **Масштабируемость чтения**: Чтение (запросы) не нагружает монолит, повышая его доступность для операций записи. | **Итоговая согласованность**: Данные в читальном хранилище обновляются с задержкой (миллисекунды, секунды). **Сложность** синхронизации. | При **высокой нагрузке на чтение** (выписки, отчеты) и необходимости разгрузить ядро. |
| **Saga (асинхронная)** | **Устойчивость к долгим процессам**: Отсутствие распределенных блокировок. Система в целом остается отзывчивой. | **Сложность отката**: Компенсирующие транзакции **не всегда атомарны**. Требуют **надежного механизма идемпотентности** (чтобы компенсация не сработала дважды). | Для **долгих бизнес-транзакций** (оформление заявки), где блокировать ресурсы на все время недопустимо. |

### Критические риски и как их смягчить

1.  **Распределенная транзакционность (Two-Phase Commit) — Антипаттерн**: Никогда не пытайтесь использовать 2PC между монолитом и сервисами. Это убьет доступность. Используйте **Saga**.
2.  **Точки отказа (SPOF)**: Strangler Fig-роутер и BFF — это SPOF. **Смягчение**: Кластеризация, активный-активный режим, circuit breaker на вызовах к ним.
3.  **Согласованность данных**: Главный враг. **Смягчение**:
    *   Для **CQRS**: Используйте надежный брокер событий (Kafka) для репликации изменений из монолита. Имейте мониторинг лага репликации.
    *   Для **Saga**: Внедрите **шаблон Idempotent Consumer** (проверка по ID сообщения) и **Панель управления Saga (Saga Orchestrator Dashboard)** для ручного исправления «застрявших» транзакций.
4.  **Вызовы из монолита в сервисы**: Избегайте их. Монолит становится зависим от менее зрелых сервисов. **Декомпозируйте по вертикали** — сервис должен быть полностью автономным.

### Стратегическая рекомендация для банка

Чаще всего работает комбинация:
1.  **Strangler Fig** — как общая стратегия миграции.
2.  **ACL** — для изоляции всех новых сервисов от ядра.
3.  **CQRS + Saga** — для нового функционала (например, онлайн-кредитование), который должен быть масштабируемым, но в итоге интегрируется с ядром для записи итогового сальдо.