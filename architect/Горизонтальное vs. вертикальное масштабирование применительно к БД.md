# Горизонтальное vs. вертикальное масштабирование

### Горизонтальное масштабирование (Scale-Out)
*   **Принцип**: Добавление **больше серверов** в кластер (узлов/инстансов).
*   **Аналогия**: Увеличение количества касс в магазине для обслуживания большего потока покупателей.
*   **Пример**: Добавление новых инстансов приложения за балансировщиком нагрузки.
*   **Плюсы**: Теоретически безгранично, выше отказоустойчивость, возможно постепенное наращивание.
*   **Минусы**: Сложность координации между узлами, нужна распределенная архитектура, выше операционные расходы.

### Вертикальное масштабирование (Scale-Up)
*   **Принцип**: Увеличение мощности **существующего сервера** (CPU, RAM, диск).
*   **Аналогия**: Замена кассира на более быстрого и опытного.
*   **Пример**: Увеличение RAM с 32ГБ до 128ГБ у сервера БД.
*   **Плюсы**: Простота реализации, не требует изменений в архитектуре.
*   **Минусы**: Физические лимиты железа, дороже мощного железа, единая точка отказа, требует простоя.

## Сравнительная таблица

| Критерий | Горизонтальное | Вертикальное |
| :--- | :--- | :--- |
| **Подход** | "Разделяй и властвуй" | "Больше мощности" |
| **Сложность** | Высокая (архитектурная) | Низкая (административная) |
| **Предел роста** | Теоретически безграничен | Ограничен одним сервером |
| **Отказоустойчивость** | Высокая (нет SPOF) | Низкая (сервер = SPOF) |
| **Стоимость** | Линейный рост | Экспоненциальный рост |
| **Типичное применение** | Микросервисы, веб-сервисы | Монолиты, RDBMS (исторически) |

**Вывод для банка**: Для современных систем и БД выбирайте **горизонтальное масштабирование**. Вертикальное — временное решение или для legacy-систем.

---

# Шардинг базы транзакций по клиентам

## Основные стратегии шардинга

### 1. Шардинг по диапазону (Range-based)
*   **Принцип**: Клиенты `A0000`-`F9999` → Шард 1, `G0000`-`Z9999` → Шард 2.
*   **Плюсы**: Простота, эффективные range-запросы.
*   **Минусы**: Риск неравномерного распределения (hot shard).
*   **Для банка**: Подходит если номер счета/клиента имеет встроенный диапазон (регион).

### 2. Шардинг по хэшу (Hash-based)
*   **Принцип**: `shard_id = hash(client_id) % N`. Распределяет данные равномерно.
*   **Плюсы**: Максимально равномерное распределение.
*   **Минусы**: Сложно делать range-запросы, изменение количества шардов требует решариинга.
*   **Для банка**: Лучший выбор для равномерной нагрузки.

### 3. Шардинг по списку (List-based)
*   **Принцип**: Явное назначение: клиенты из `["Банк Москвы", "Сбер"]` → Шард 1, `["Тинькофф", "Альфа"]` → Шард 2.
*   **Плюсы**: Полный контроль.
*   **Минусы**: Ручное управление, дисбаланс.
*   **Для банка**: Для изоляции VIP-клиентов или юридических лиц.

### 4. Геошардинг
*   **Принцип**: Клиенты из Москвы → Шард в ЦОД Москвы, СПб → Шард в ЦОД СПб.
*   **Плюсы**: Низкая задержка, соответствие регуляторным требованиям (данные в стране).
*   **Минусы**: Сложность, возможный дисбаланс.
*   **Для банка**: Критически важно для соблюдения 152-ФЗ и подобных.

## Практические шаги для реализации

### 1. Выбор ключа шардирования
*   **Идеальный ключ**: `client_id` или `account_id`.
*   **Важно**: Все данные клиента (транзакции, балансы, карты) должны шардироваться **по одному ключу** (colocated sharding), чтобы избежать распределенных JOIN.

### 2. Архитектура доступа к данным
```
[Приложение] → [Роутер шардов / Прокси]
                           ↓
          [Шард 1]   [Шард 2]   [Шард N]
          (Клиенты   (Клиенты   (Клиенты
           A-G)       H-R)       S-Z)
```
*   Используйте **Vitess**, **Citus** (для PostgreSQL) или **ProxySQL** как промежуточный слой.
*   Или внедрите шаблон **Database-per-Service** на уровне приложения.

### 3. Схема данных в шарде
```sql
-- В каждом шарде идентичная схема, но разные данные
CREATE TABLE transactions (
    id BIGSERIAL,
    client_id VARCHAR(20) NOT NULL, -- Ключ шардирования
    account_id VARCHAR(20) NOT NULL,
    amount DECIMAL(15,2),
    created_at TIMESTAMPTZ
) PARTITION BY HASH(client_id); -- Дополнительное партиционирование внутри шарда
```

### 4. Решение проблем шардирования

| Проблема | Решение |
| :--- | :--- |
| **Глобальные запросы** | Создайте **отдельный "справочный" шард** для мелких таблиц или реплицируйте их во все шарды. |
| **Балансировка нагрузки** | Используйте **виртуальные шарды**: логических шардов больше, чем физических серверов, для гибкого перемещения. |
| **Репликация для отказоустойчивости** | Каждый шард должен иметь **реплики (master-slave или multi-master)**. |
| **Миграция данных (решаридинг)** | Используйте **двойную запись** во время миграции: пишите и в старый, и в новый шард. |

## Критически важные проверки для банка

1.  **Транзакционность в пределах одного шарда**: Дизайн так, чтобы все операции в рамках одной бизнес-транзакции (списание + зачисление) попадали в **один шард**. Используйте **Saga** для распределенных транзакций.
2.  **Консистентность**: Настройте синхронную репликацию в рамках шарда, но будьте готовы к асинхронной репликации между шардами.
3.  **Аудит и мониторинг**: Внедрите централизованный сбор логов и метрик по всем шардам.
4.  **Резервное копирование**: Организуйте бэкап каждого шарда независимо с учетом RTO/RPO.

## Пример реализации на уровне приложения (Spring)
```java
@Component
public class ShardRouter {
    // Определяет шард по client_id (например, по хэшу)
    public DataSource determineDataSource(String clientId) {
        int shardNumber = Math.abs(clientId.hashCode() % SHARD_COUNT);
        return dataSourceMap.get(shardNumber);
    }
}

@Service
public class TransactionService {
    @Transactional // Работает с одним DataSource (одним шардом)
    public void processTransaction(TransactionRequest request) {
        DataSource shardDataSource = shardRouter
            .determineDataSource(request.getClientId());
        // Использовать shardDataSource для работы с БД
    }
}
```

## Золотые правила шардинга в банке
1.  **Откладывайте шардинг до последнего**: Сначала используйте партиционирование, индексы, кэширование.
2.  **Шардируйте по бизнес-сущности**: Ключ должен соответствовать основному пути доступа (клиент → все его операции).
3.  **Автоматизируйте управление**: Ручное перемещение шардов недопустимо в продакшене.
4.  **Тестируйте на реалистичных данных**: Смоделируйте распределение клиентов и транзакционную нагрузку.
